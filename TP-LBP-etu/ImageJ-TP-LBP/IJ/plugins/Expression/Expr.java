import java.lang.Math;import java.util.Random;import ij.ImagePlus;import ij.process.ImageProcessor;public abstract class Expr {	/* We need to be careful about the access rights to fields and methods:		'public' for items that should be visible from the expression code,			and which are set from ExpressionNT.		'protected' for items that should be visible from the expression code,			and which are not set from the ExpressionNT code.		'private' for items that should not be visible from the expression code.	*/	final int RGB = 1;	final int HLS = 2;	final int HSV = 3;	final int GRAY = 4;	final static protected double ln10=Math.log(10), pi=Math.PI, e=Math.E;	protected Random rnd = new Random(System.currentTimeMillis());	public double i, r, g, b, wr, hr, maxval;	public int w, h, rw, rh, n, t;	protected double x, y;	protected int xi, yi;	private int type, maxIter, colorModel=0;	private boolean maxIs0;	private boolean XorYisNew;	private boolean hWarn, sWarn, lWarn, vWarn;	private double hC, sC, lC, vC;	private ImageProcessor[] ipArray;	Expr() {		n = 1;		t = 0;		XorYisNew = true;		hWarn = sWarn = lWarn = vWarn = false;		hC = sC = lC = vC = 0.0;	}	public void setX (int x, double xR) {		this.x = xR;		this.xi = x;		XorYisNew = true;	}	public void setY (int y, double yR) {		this.y = yR;		this.yi = y;		XorYisNew = true;	}	public void setNumSlices (int slices) {		n = slices;	}	public void setColorModel (String colorModel) {		if ("Gray".equals(colorModel))			this.colorModel = GRAY;		else if ("HLS".equals(colorModel))			this.colorModel = HLS;		else if ("HSV".equals(colorModel))			this.colorModel = HSV;		else if ("RGB".equals(colorModel))			this.colorModel = RGB;	}	public void setMaxIter (int maxIter) { this.maxIter = maxIter; }	public void setMaxIs0 (boolean maxIs0) { this.maxIs0 = maxIs0; }	public void setType (int type) { this.type = type; }	public void setIPArray (ImageProcessor[] ipArray) { this.ipArray = ipArray; }	// calculation methods	public abstract double calcR();	public abstract double calcG();	public abstract double calcB();	public abstract double calcMin();	public abstract double calcMax();	public abstract double calcX();	public abstract double calcY();	public abstract double calcW();	public abstract double calcH();	protected double i (int n) { return i(xi, yi, n); }	protected double r (int n) { return r(xi, yi, n); }	protected double g (int n) { return g(xi, yi, n); }	protected double b (int n) { return b(xi, yi, n); }	protected double i (double x, double y) { return i(x, y, t); }	protected double r (double x, double y) { return r(x, y, t); }	protected double g (double x, double y) { return g(x, y, t); }	protected double b (double x, double y) { return b(x, y, t); }	int val;	protected double i (double x, double y, int n) {		switch (type) {			case ImagePlus.GRAY8:			case ImagePlus.COLOR_256:				val = ipArray[n-1].getPixel((int)x, (int)y);				return val<0 ? 256+val : val;			case ImagePlus.GRAY16:				val = ipArray[n-1].getPixel((int)x, (int)y);				return val<0 ? 65536+val : val;			case ImagePlus.GRAY32:				return Float.intBitsToFloat(ipArray[n-1].getPixel((int)x, (int)y));			case ImagePlus.COLOR_RGB:				// I is not really defined for RGB images; we'll just return the red component				return r(x, y, n);		}		return 0.0;	}	protected double r (double x, double y, int n) {		switch (type) {			case ImagePlus.COLOR_RGB:				val = (ipArray[n-1].getPixel((int)x, (int)y) & 0xff0000) >> 16;				return val<0 ? val+256 : val;			default:				return i(x, y, n);		}	}	protected double g (double x, double y, int n) {		switch (type) {			case ImagePlus.COLOR_RGB:				val = (ipArray[n-1].getPixel((int)x, (int)y) & 0x00ff00) >> 8;				return val<0 ? val+256 : val;			default:				return i(x, y, n);		}	}	protected double b (double x, double y, int n) {		switch (type) {			case ImagePlus.COLOR_RGB:				val = (ipArray[n-1].getPixel((int)x, (int)y) & 0x0000ff);				return val<0 ? val+256 : val;			default:				return i(x, y, n);		}	}// Add any new functions you want to use to the following list	public double sin (double arg) { return Math.sin(arg); }	public double cos (double arg) { return Math.cos(arg); }	public double tan (double arg) { return Math.tan(arg); }	public double asin (double arg) { return Math.asin(arg); }	public double acos (double arg) { return Math.acos(arg); }	public double atan (double arg) { return Math.atan(arg); }	public double sqrt (double arg) { return Math.sqrt(arg); }	public double log (double arg) { return Math.log(arg) / ln10; }	public double ln (double arg) { return Math.log(arg); }	public double exp (double arg) { return Math.exp(arg); }	public double floor (double arg) { return Math.floor(arg); }	public double ceil (double arg) { return Math.ceil(arg); }	public double round (double arg) { return Math.round(arg); }	public double abs (double arg) { return Math.abs(arg); }	public double pow (double arg1, double arg2) { return Math.pow(arg1, arg2); }	public double rnd() { return rnd.nextDouble(); }	public double min (double a1, double a2) { return a1<a2 ? a1 : a2; }	public double min (double a1, double a2, double a3) { return a1<a2 ? (a1<a3 ? a1 : a3) : (a2<a3 ? a2 : a3); }	public double max (double a1, double a2) { return a1>a2 ? a1 : a2; }	public double max (double a1, double a2, double a3) { return a1>a2 ? (a1>a3 ? a1 : a3) : (a2>a3 ? a2 : a3); }	// distance	public double d() {		double dx = x - Math.floor(wr/2.0);		double dy = y - Math.floor(hr/2.0);		return Math.sqrt(dx*dx + dy*dy);	}	// angle	public double a() {		double xx = x - wr/2.0;		double yy = y - hr/2.0;		double r = Math.atan(yy / xx);		if (xx<0)					// 2nd and 3rd quadrant			return r + pi;		else if (xx>=0 && yy<0)		// 4th quadrant			return r + 2.0*pi;		else			return r;	}	// Mandelbrot function with iterator function z = z^2 + c	public double mand() {// instead of simply calling mand(2), we use a slightly optimized version//		return mand(2);		int i=0;		double zre = x, zim = y;		double dre = zre * zre, dim = zim * zim;		while ((dre + dim <= 4.0) && (i < maxIter)) {			zim = 2.0*zre*zim + y;			zre = dre - dim + x;			dre = zre * zre;			dim = zim * zim;			i++;		}		if (maxIs0 && (i == maxIter))			i = 0;		return i;	}	// generalized Mandelbrot function with iterator function z = z^n + c	public double mand (int exponent) {		int i=0, loop;		double zre = x, zim = y, tmp;		double dre = zre * zre, dim = zim * zim;		double zre1 = zre, zim1 = zim;		while ((dre + dim <= 4.0) && (i < maxIter)) {            for (loop=1; loop<exponent; loop++) {                tmp = zim;                zim = zre*zim1 + zim*zre1;                zre = zre*zre1 - tmp*zim1;			}			zim += y;			zre += x;			zre1 = zre;			zim1 = zim;			dre = zre * zre;			dim = zim * zim;			i++;		}		if (maxIs0 && (i == maxIter))			i = 0;		return i;	}	/* H, S, V and L are only calculated if they're actually used in a formula.	 * They're calculated once for each pixel, and then stored in the hC/sC/vC/lC	 * variables, whose values are invalidated when either x or y change.	 * If any of the functions are called while dealing with an image using a	 * color model that doesn't support them, a warning is issued.	 * These checks make the functions larger than they'd really need to be.	 */	// Hue	public double h() {		if (XorYisNew) {			switch (colorModel) {				case HLS: RGB2HLS(); break;				case HSV: RGB2HSV(); break;				default:					if (!hWarn) {						System.err.println("The h() function is only available in the HLS and HSV color models.");						hWarn = true;					}			}			XorYisNew = false;		}		return hC;	}	// Lightness	public double l() {		if (XorYisNew) {			if (colorModel == HLS) {				RGB2HLS();			} else {				if (!lWarn) {					System.err.println("The l() function is only available in the HLS color model.");					lWarn = true;				}			}			XorYisNew = false;		}		return lC;	}	// Saturation	public double s() {		if (XorYisNew) {			switch (colorModel) {				case HLS: RGB2HLS(); break;				case HSV: RGB2HSV(); break;				default:					if (!sWarn) {						System.err.println("The s() function is only available in the HLS and HSV color models.");						sWarn = true;					}			}			XorYisNew = false;		}		return sC;	}	// Value	public double v() {		if (XorYisNew) {			if (colorModel == HSV) {				RGB2HSV();			} else {				if (!vWarn) {					System.err.println("The v() function is only available in the HSV color model.");					vWarn = true;				}			}			XorYisNew = false;		}		return vC;	}	private void RGB2HLS() {		double max, min, rd, gd, bd, tmp, ru=r/255.0, gu=g/255.0, bu=b/255.0;		max = max(ru,gu,bu);		min = min(ru,gu,bu);		lC = (max + min) / 2.0;		tmp = max - min;		if (tmp == 0.0) {			sC = 0.0;			hC = 0.0;		} else {			if (lC > 0.5)				sC = tmp / (2.0 - max - min);			else				sC = tmp / (max + min);			rd = (max - ru) / tmp;			gd = (max - gu) / tmp;			bd = (max - bu) / tmp;			if (max == ru) {				if (min == gu)					hC = 1.0 + bd;				else					hC = 3.0 - gd;			} else if (max == gu) {				if (min == bu)					hC = 3.0 + rd;				else					hC = 5.0 - bd;			} else {				if (min == ru)					hC = 5.0 + gd;				else					hC = 1.0 - rd;			}			if (hC < 6.0)				hC *= 60.0;			else				hC = 0.0;		}	}	private void RGB2HSV() {		double rd, gd, bd, min, tmp, ru=r/255.0, gu=g/255.0, bu=b/255.0;		vC = max(ru,gu,bu);		min = min(ru,gu,bu);		tmp = vC - min;		if (vC > 0.0)			sC = tmp / vC;		else			sC = 0.0;		if (sC > 0.0) {			rd = (vC - ru) / tmp;			gd = (vC - gu) / tmp;			bd = (vC - bu) / tmp;			if (vC == ru) {				if (min == gu)					hC = 5.0 + bd;				else					hC = 1.0 - gd;			} else if (vC == gu) {				if (min == bu)					hC = 1.0 + rd;				else					hC = 3.0 - bd;			} else {				if (min == ru)					hC = 3.0 + gd;				else					hC = 5.0 - rd;			}			if (hC < 6.0)				hC *= 60.0;			else				hC = 0.0;		} else {			hC = Double.NaN;		}	}}